;
; File generated by cc65 v 2.18 - Git 24c8e3f
;
	.fopt		compiler,"cc65 v 2.18 - Git 24c8e3f"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_g_ppu_addr
	.import		_g_ppu_data
	.import		_g_ppu_data_size
	.import		_ppu_reset_scroll
	.import		_ppu_enable
	.import		_ppu_write
	.import		_ppu_disable
	.importzp	_g_frame_count
	.importzp	_g_input_port_1
	.import		_wait_frame
	.import		_g_text
	.import		_g_blank_text
	.import		_g_palettes
	.import		_g_attributes
	.import		_g_i
	.import		_g_j
	.import		_g_attr_offset
	.import		_g_state
	.import		_g_sprites
	.import		_g_levels
	.export		_init_level
	.export		_update
	.export		_draw_background
	.export		_clear_sprites
	.export		_main

; ---------------------------------------------------------------
; void __near__ init_level (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_init_level: near

.segment	"CODE"

;
; ppu_disable();
;
	jsr     _ppu_disable
;
; g_ppu_addr = PPU_PALETTE;
;
	ldx     #$3F
	lda     #$00
	sta     _g_ppu_addr
	stx     _g_ppu_addr+1
;
; g_ppu_data = (unsigned char *) g_palettes;
;
	lda     #>(_g_palettes)
	sta     _g_ppu_data+1
	lda     #<(_g_palettes)
	sta     _g_ppu_data
;
; g_ppu_data_size = G_PALETTE_LEN;
;
	lda     #$20
	sta     _g_ppu_data_size
;
; ppu_write();
;
	jsr     _ppu_write
;
; draw_background();
;
	jsr     _draw_background
;
; g_ppu_addr = PPU_NAMETABLE_0 + G_TEXT_OFFSET;
;
	ldx     #$21
	lda     #$CA
	sta     _g_ppu_addr
	stx     _g_ppu_addr+1
;
; g_ppu_data = (unsigned char *) (g_state == TITLE_SCREEN ? g_text : g_blank_text);
;
	lda     _g_state
	ora     _g_state+1
	bne     L0084
	lda     #<(_g_text)
	ldx     #>(_g_text)
	jmp     L0086
L0084:	lda     #<(_g_blank_text)
	ldx     #>(_g_blank_text)
L0086:	sta     _g_ppu_data
	stx     _g_ppu_data+1
;
; g_ppu_data_size = G_TEXT_LEN;
;
	lda     #$0E
	sta     _g_ppu_data_size
;
; ppu_write();
;
	jsr     _ppu_write
;
; g_ppu_addr = PPU_ATTRIB_TABLE_0 + ATTR_OFFSET;
;
	ldx     #$23
	lda     #$DA
	sta     _g_ppu_addr
	stx     _g_ppu_addr+1
;
; g_ppu_data = (unsigned char *) g_attributes;
;
	lda     #>(_g_attributes)
	sta     _g_ppu_data+1
	lda     #<(_g_attributes)
	sta     _g_ppu_data
;
; g_ppu_data_size = ATTR_SIZE;
;
	lda     #$04
	sta     _g_ppu_data_size
;
; ppu_write();
;
	jsr     _ppu_write
;
; ppu_reset_scroll();
;
	jsr     _ppu_reset_scroll
;
; ppu_enable();
;
	jmp     _ppu_enable

.endproc

; ---------------------------------------------------------------
; void __near__ update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update: near

.segment	"CODE"

;
; wait_frame();
;
	jsr     _wait_frame
;
; ppu_reset_scroll();
;
	jsr     _ppu_reset_scroll
;
; switch(g_state) {
;
	lda     _g_state
	ldx     _g_state+1
;
; }
;
	cpx     #$00
	beq     L00EB
;
; }
;
	rts
;
; }
;
L00EB:	cmp     #$00
	beq     L00D8
	cmp     #$01
	beq     L00DA
	rts
;
; if(g_frame_count >= (FRAMES_PER_SEC / 4)) {
;
L00D8:	lda     _g_frame_count
	cmp     #$0F
	bcc     L00D9
;
; g_ppu_data = (unsigned char *) g_attributes + g_attr_offset;
;
	lda     _g_attr_offset
	clc
	adc     #<(_g_attributes)
	sta     _g_ppu_data
	txa
	adc     #>(_g_attributes)
	sta     _g_ppu_data+1
;
; ppu_write();
;
	jsr     _ppu_write
;
; g_attr_offset += ATTR_SIZE;
;
	lda     #$04
	clc
	adc     _g_attr_offset
	sta     _g_attr_offset
;
; if(g_attr_offset == G_ATTR_LEN)
;
	cmp     #$0C
	bne     L0026
;
; g_attr_offset = 0;
;
	lda     #$00
	sta     _g_attr_offset
;
; ppu_reset_scroll();
;
L0026:	jsr     _ppu_reset_scroll
;
; g_frame_count = 0;
;
	lda     #$00
	sta     _g_frame_count
;
; if(g_input_port_1 & BUTTON_START) {
;
L00D9:	lda     _g_input_port_1
	and     #$10
	bne     L00EC
;
; }
;
	rts
;
; g_state = TEST_ROOM;
;
L00EC:	ldx     #$00
	lda     #$01
	sta     _g_state
	stx     _g_state+1
;
; g_sprites[PLAYER_SPRITE_ID].x = (MAX_X / 2) - (SPRITE_WIDTH / 2);
;
	lda     #$7C
	sta     _g_sprites+3
;
; g_sprites[PLAYER_SPRITE_ID].y = (MAX_Y / 2) - (SPRITE_HEIGHT / 2) + 24;
;
	lda     #$87
	sta     _g_sprites
;
; g_sprites[PLAYER_SPRITE_ID].tile_index = SPR_PLAYER;
;
	lda     #$10
	sta     _g_sprites+1
;
; g_sprites[PLAYER_SPRITE_ID].attributes = 0;
;
	stx     _g_sprites+2
;
; init_level();
;
	jmp     _init_level
;
; if(g_input_port_1 & BUTTON_UP && g_sprites[PLAYER_SPRITE_ID].y > MIN_Y + SPRITE_HEIGHT) {
;
L00DA:	lda     _g_input_port_1
	and     #$08
	beq     L00DE
	lda     _g_sprites
	cmp     #$11
	bcc     L00DE
;
; -- g_sprites[PLAYER_SPRITE_ID].y;
;
	dec     _g_sprites
;
; if(g_input_port_1 & BUTTON_DOWN && g_sprites[PLAYER_SPRITE_ID].y < MAX_Y - (SPRITE_HEIGHT << 1)) {
;
L00DE:	lda     _g_input_port_1
	and     #$04
	beq     L00E2
	lda     _g_sprites
	cmp     #$D7
	bcs     L00E2
;
; ++ g_sprites[PLAYER_SPRITE_ID].y;
;
	inc     _g_sprites
;
; if(g_input_port_1 & BUTTON_LEFT && g_sprites[PLAYER_SPRITE_ID].x > MIN_X + SPRITE_HEIGHT) {
;
L00E2:	lda     _g_input_port_1
	and     #$02
	beq     L00E6
	lda     _g_sprites+3
	cmp     #$09
	bcc     L00E6
;
; -- g_sprites[PLAYER_SPRITE_ID].x;
;
	dec     _g_sprites+3
;
; if(g_input_port_1 & BUTTON_RIGHT && g_sprites[PLAYER_SPRITE_ID].x < MAX_X - (SPRITE_HEIGHT << 1)) {
;
L00E6:	lda     _g_input_port_1
	and     #$01
	beq     L00EA
	lda     _g_sprites+3
	cmp     #$F0
	bcs     L00EA
;
; ++ g_sprites[PLAYER_SPRITE_ID].x;
;
	inc     _g_sprites+3
;
; if(g_input_port_1 & BUTTON_SELECT) {
;
L00EA:	lda     _g_input_port_1
	and     #$20
	beq     L001B
;
; g_state = TITLE_SCREEN;
;
	txa
	sta     _g_state
	sta     _g_state+1
;
; g_sprites[PLAYER_SPRITE_ID].x = 0;
;
	sta     _g_sprites+3
;
; g_sprites[PLAYER_SPRITE_ID].y = 0;
;
	sta     _g_sprites
;
; g_sprites[PLAYER_SPRITE_ID].tile_index = BLANK_TILE;
;
	sta     _g_sprites+1
;
; g_sprites[PLAYER_SPRITE_ID].attributes = 0;
;
	sta     _g_sprites+2
;
; init_level();
;
	jmp     _init_level
;
; }
;
L001B:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ draw_background (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_background: near

.segment	"CODE"

;
; PPU_ADDR = (unsigned char) ((PPU_NAMETABLE_0 + NAMETABLE_OFFSET) >> 8);
;
	lda     #$20
	sta     $2006
;
; PPU_ADDR = (unsigned char) (PPU_NAMETABLE_0 + NAMETABLE_OFFSET);
;
	sta     $2006
;
; for(g_j = 0; g_j < NUM_ROWS; ++g_j) {
;
	lda     #$00
	sta     _g_j
L00EF:	lda     _g_j
	cmp     #$1C
	bcs     L00A5
;
; for(g_i = 0; g_i < NUM_COLS; ++g_i) {
;
	lda     #$00
	sta     _g_i
L00F0:	lda     _g_i
	cmp     #$20
	bcs     L00F2
;
; switch(g_state) {
;
	lda     _g_state+1
;
; }
;
	bne     L00F1
;
; switch(g_state) {
;
	lda     _g_state
;
; }
;
	cmp     #$01
	bne     L00F1
;
; PPU_DATA = g_levels[TEST_ROOM_LEVEL_ID].bg[g_j][g_i];
;
	ldx     #$00
	lda     _g_j
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #<(_g_levels)
	sta     ptr1
	lda     tmp1
	adc     #>(_g_levels)
	sta     ptr1+1
	ldy     _g_i
	lda     (ptr1),y
;
; break;
;
	jmp     L00EE
;
; PPU_DATA = BLANK_TILE;
;
L00F1:	lda     #$00
L00EE:	sta     $2007
;
; for(g_i = 0; g_i < NUM_COLS; ++g_i) {
;
	inc     _g_i
	jmp     L00F0
;
; for(g_j = 0; g_j < NUM_ROWS; ++g_j) {
;
L00F2:	inc     _g_j
	jmp     L00EF
;
; }
;
L00A5:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ clear_sprites (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clear_sprites: near

.segment	"CODE"

;
; for(g_i = 0; g_i < MAX_SPRITES; ++g_i) {
;
	lda     #$00
	sta     _g_i
L00F3:	lda     _g_i
	cmp     #$40
	bcs     L00C5
;
; g_sprites[g_i].attributes = 0;
;
	ldx     #$00
	lda     _g_i
	jsr     aslax2
	clc
	adc     #<(_g_sprites)
	sta     ptr1
	txa
	adc     #>(_g_sprites)
	sta     ptr1+1
	lda     #$00
	ldy     #$02
	sta     (ptr1),y
;
; g_sprites[g_i].x = 0;
;
	tax
	lda     _g_i
	jsr     aslax2
	clc
	adc     #<(_g_sprites)
	sta     ptr1
	txa
	adc     #>(_g_sprites)
	sta     ptr1+1
	lda     #$00
	iny
	sta     (ptr1),y
;
; g_sprites[g_i].y = 0;
;
	tax
	lda     _g_i
	jsr     aslax2
	clc
	adc     #<(_g_sprites)
	sta     ptr1
	txa
	adc     #>(_g_sprites)
	sta     ptr1+1
	lda     #$00
	tay
	sta     (ptr1),y
;
; g_sprites[g_i].tile_index = BLANK_TILE;
;
	tax
	lda     _g_i
	jsr     aslax2
	clc
	adc     #<(_g_sprites)
	sta     ptr1
	txa
	adc     #>(_g_sprites)
	sta     ptr1+1
	tya
	iny
	sta     (ptr1),y
;
; for(g_i = 0; g_i < MAX_SPRITES; ++g_i) {
;
	inc     _g_i
	jmp     L00F3
;
; }
;
L00C5:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; clear_sprites();
;
	jsr     _clear_sprites
;
; g_state = TITLE_SCREEN;
;
	lda     #$00
	sta     _g_state
	sta     _g_state+1
;
; init_level();
;
	jsr     _init_level
;
; g_attr_offset = ATTR_SIZE;
;
	lda     #$04
	sta     _g_attr_offset
;
; update();
;
L0011:	jsr     _update
;
; while(1) {
;
	jmp     L0011

.endproc

